# 浏览器解析流程

- [How browsers work](https://blog.csdn.net/zzzaquarius/article/details/6532299/)
- [性能分析工具](https://github.com/pod4g/hiper/blob/master/README.zh-CN.md)
- [页面优化](https://segmentfault.com/a/1190000010298038)
- [渲染过程](https://blog.csdn.net/xiaozhuxmen/article/details/52014901)
- [浏览器加载、解析、渲染的过程](https://blog.csdn.net/xiaozhuxmen/article/details/52014901)

## 获取数据阶段

1. 用户输入URL地址

2. 浏览器解析URL解析出主机名

3. 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）

4. 浏览器将端口号从URL中解析出来

5. 浏览器建立一条与目标Web服务器的TCP连接（三次握手）

6. 浏览器向服务器发送一条HTTP请求报文

7. 服务器向浏览器返回一条HTTP响应报文

8. 关闭连接 浏览器解析文档

如果文档中有资源(img,js,css),重复5678动作,直至资源全部加载完毕

## 解析流程

### 绘制顺序

一个块渲染对象的堆栈顺序是：

1. 背景色

2. 背景图

3. border

4. children

5. outline

### 渲染引擎的线程

渲染引擎是单线程的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的主线程，Chrome中这是tab的主线程。

网络操作由几个并行线程执行，并行连接的个数是受限的（通常是2－6个）。

### 事件循环

浏览器主线程是一个事件循环，它被设计为无限循环以保持执行过程的可用，等待事件（例如layout和paint事件）并执行它们。下面是Firefox的主要事件循环代码。

### Chrome调试工具查看页面渲染顺序

在改变文档根元素的字体颜色等视觉性信息时，会触发整个文档的重绘，而改变某元素的字体颜色则只触发特定元素的重绘；改变元素的位置信息会同时触发此元素（可能还包括其兄弟元素或子级元素）的布局和重绘。某些重大改变，如更改文档根元素的字体尺寸，则会触发整个文档的重新布局和重绘，据此及上文所述，推荐以下优化和实践：

1. 发起请求；

2. 解析HTML；

3. 解析样式；

4. 执行JavaScript；

5. 布局；

6. 绘制

### 页面渲染优化

1. HTML文档结构层次尽量少，最好不深于六层；

2. 脚本尽量后放，放在前即可；

3. 少量首屏样式内联放在标签内；

4. 样式结构层次尽量简单；

5. 在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流；

6. 减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；

7. 动画尽量使用在绝对定位或固定定位的元素上；

8. 隐藏在屏幕外，或在页面滚动时，尽量停止动画；

9. 尽量缓存DOM查找，查找器尽量简洁；

10. 涉及多域名的网站，可以开启域名预解析

## 解析流程2

为什么要了解浏览器加载、解析、渲染这个过程？

好，我们先说一下，为什么要了解这些呢？如果想写出一个最佳实践的页面，就要好好了解。

- 了解浏览器如何进行加载，可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。
- 了解浏览器如何进行解析，可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。
- 了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写js文件时，可以减少"reflow""repaint"的消耗。

下面是渲染引擎在取得内容之后的基本流程：

```text
解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树
```

所以，浏览器会解析三个东西：

1. HTML/SVG/XHTML，解析这三种文件会产生一个 DOM Tree。
2. CSS，解析 CSS 会产生 CSS 规则树。
3. Javascript脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree.

```text
当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。
解析：
1.浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
2.将CSS解析成 CSS Rule Tree 。
3.根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。
4.有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。
5.再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。
```

上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

**几个概念：**

（1）Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。

（2）Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。 Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。

**reflow的原因：**

```text
（1）页面初始化的时候；
（2）操作DOM时；
（3）某些元素的尺寸变了；
（4）如果 CSS 的属性发生变化了。
```

**减少reflow/repaint**

```text
（1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。
（3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。
（4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
```

综上所述，关于浏览器加载、解析、渲染过程如下:

```text
1.用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；

2.浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；

3.浏览器又发出CSS文件的请求，服务器返回这个CSS文件；

4.浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；

5.浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；

6.服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；

7.浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它；

8.Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码；

9.终于等到了＜/html＞的到来，浏览器泪流满面……

10.等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径；

11.浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。
```

### 编写CSS时应该注意

CSS选择符是从右到左进行匹配的。从右到左！所以，`#nav li` 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav。，因此，写css的时候需要注意：

1. dom深度尽量浅。

2. 减少inline javascript、css的数量。

3. 使用现代合法的css属性。

4. 不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。

5. 避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。

6. 避免使用通配符，举一个例子，`.mod .hd *{font-size:14px;}` 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.

### Javascript的加载和执行的特点

1. 将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。
2. 尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。
